{"code":"(this[\"webpackJsonpcs-central\"]=this[\"webpackJsonpcs-central\"]||[]).push([[74],{557:function(e,n,a){\"use strict\";function t(e){!function(e){function n(e){return RegExp(\"(\\\\()\"+e+\"(?=[\\\\s\\\\)])\")}function a(e){return RegExp(\"([\\\\s([])\"+e+\"(?=[\\\\s)])\")}var t=\"[-+*/_~!@$%^=<>{}\\\\w]+\",s=\"(\\\\()\",i=\"(?=\\\\))\",r={heading:{pattern:/;;;.*/,alias:[\"comment\",\"title\"]},comment:/;.*/,string:{pattern:/\"(?:[^\"\\\\]|\\\\.)*\"/,greedy:!0,inside:{argument:/[-A-Z]+(?=[.,\\s])/,symbol:RegExp(\"`\"+t+\"'\")}},\"quoted-symbol\":{pattern:RegExp(\"#?'\"+t),alias:[\"variable\",\"symbol\"]},\"lisp-property\":{pattern:RegExp(\":\"+t),alias:\"property\"},splice:{pattern:RegExp(\",@?\"+t),alias:[\"symbol\",\"variable\"]},keyword:[{pattern:RegExp(\"(\\\\()(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)(?=\\\\s)\"),lookbehind:!0},{pattern:RegExp(\"(\\\\()(?:for|do|collect|return|finally|append|concat|in|by)(?=\\\\s)\"),lookbehind:!0}],declare:{pattern:n(\"declare\"),lookbehind:!0,alias:\"keyword\"},interactive:{pattern:n(\"interactive\"),lookbehind:!0,alias:\"keyword\"},boolean:{pattern:a(\"(?:t|nil)\"),lookbehind:!0},number:{pattern:a(\"[-+]?\\\\d+(?:\\\\.\\\\d*)?\"),lookbehind:!0},defvar:{pattern:RegExp(\"(\\\\()def(?:var|const|custom|group)\\\\s+\"+t),lookbehind:!0,inside:{keyword:/^def[a-z]+/,variable:RegExp(t)}},defun:{pattern:RegExp(\"(\\\\()(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+\"+t+\"\\\\s+\\\\([\\\\s\\\\S]*?\\\\)\"),lookbehind:!0,inside:{keyword:/^(?:cl-)?def\\S+/,arguments:null,function:{pattern:RegExp(\"(^\\\\s)\"+t),lookbehind:!0},punctuation:/[()]/}},lambda:{pattern:RegExp(\"(\\\\()lambda\\\\s+\\\\((?:&?\"+t+\"\\\\s*)*\\\\)\"),lookbehind:!0,inside:{keyword:/^lambda/,arguments:null,punctuation:/[()]/}},car:{pattern:RegExp(s+t),lookbehind:!0},punctuation:[/(['`,]?\\(|[)\\[\\]])/,{pattern:/(\\s)\\.(?=\\s)/,lookbehind:!0}]},o={\"lisp-marker\":RegExp(\"&[-+*/_~!@$%^=<>{}\\\\w]+\"),rest:{argument:{pattern:RegExp(t),alias:\"variable\"},varform:{pattern:RegExp(s+t+\"\\\\s+\\\\S[\\\\s\\\\S]*\"+i),lookbehind:!0,inside:{string:r.string,boolean:r.boolean,number:r.number,symbol:r.symbol,punctuation:/[()]/}}}},l=\"\\\\S+(?:\\\\s+\\\\S+)*\",p={pattern:RegExp(\"(\\\\()[\\\\s\\\\S]*(?=\\\\))\"),lookbehind:!0,inside:{\"rest-vars\":{pattern:RegExp(\"&(?:rest|body)\\\\s+\"+l),inside:o},\"other-marker-vars\":{pattern:RegExp(\"&(?:optional|aux)\\\\s+\"+l),inside:o},keys:{pattern:RegExp(\"&key\\\\s+\"+l+\"(?:\\\\s+&allow-other-keys)?\"),inside:o},argument:{pattern:RegExp(t),alias:\"variable\"},punctuation:/[()]/}};r.lambda.inside.arguments=p,r.defun.inside.arguments=e.util.clone(p),r.defun.inside.arguments.inside.sublist=p,e.languages.lisp=r,e.languages.elisp=r,e.languages.emacs=r,e.languages[\"emacs-lisp\"]=r}(e)}e.exports=t,t.displayName=\"lisp\",t.aliases=[]}}]);","name":"static/js/react-syntax-highlighter_languages_refractor_lisp.08909064.chunk.js","map":{"version":3,"sources":["static/js/react-syntax-highlighter_languages_refractor_lisp.08909064.chunk.js"],"names":["this","push","557","module","exports","__webpack_require__","lisp","Prism","simple_form","name","RegExp","primitive","pattern","symbol","par","endpar","language","heading","alias","comment","string","greedy","inside","argument","quoted-symbol","lisp-property","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","lisp-marker","rest","varform","forms","arglist","rest-vars","other-marker-vars","keys","util","clone","sublist","languages","elisp","emacs","displayName","aliases"],"mappings":"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"},"input":"(this[\"webpackJsonpcs-central\"] = this[\"webpackJsonpcs-central\"] || []).push([[74],{\n\n/***/ 557:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = lisp;\nlisp.displayName = 'lisp';\nlisp.aliases = [];\n\nfunction lisp(Prism) {\n  ;\n\n  (function (Prism) {\n    // Functions to construct regular expressions\n    // simple form\n    // e.g. (interactive ... or (interactive)\n    function simple_form(name) {\n      return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])');\n    } // booleans and numbers\n\n\n    function primitive(pattern) {\n      return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])');\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n\n\n    var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+'; // symbol starting with & used in function arguments\n\n    var marker = '&' + symbol; // Open parenthesis for look-behind\n\n    var par = '(\\\\()';\n    var endpar = '(?=\\\\))'; // End the pattern with look-ahead space\n\n    var space = '(?=\\\\s)';\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [{\n        pattern: RegExp(par + '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' + space),\n        lookbehind: true\n      }, {\n        pattern: RegExp(par + '(?:for|do|collect|return|finally|append|concat|in|by)' + space),\n        lookbehind: true\n      }],\n      declare: {\n        pattern: simple_form('declare'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form('interactive'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive('(?:t|nil)'),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(par + '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' + symbol + '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'),\n        lookbehind: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n        lookbehind: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [// open paren, brackets, and close paren\n      /(['`,]?\\(|[)\\[\\]])/, // cons\n      {\n        pattern: /(\\s)\\.(?=\\s)/,\n        lookbehind: true\n      }]\n    };\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      rest: {\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        varform: {\n          pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n          lookbehind: true,\n          inside: {\n            string: language.string,\n            boolean: language.boolean,\n            number: language.number,\n            symbol: language.symbol,\n            punctuation: /[()]/\n          }\n        }\n      }\n    };\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*';\n    var arglist = {\n      pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    };\n    language['lambda'].inside.arguments = arglist;\n    language['defun'].inside.arguments = Prism.util.clone(arglist);\n    language['defun'].inside.arguments.inside.sublist = arglist;\n    Prism.languages.lisp = language;\n    Prism.languages.elisp = language;\n    Prism.languages.emacs = language;\n    Prism.languages['emacs-lisp'] = language;\n  })(Prism);\n}\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/Users/destul/Desktop/cs-central/node_modules/refractor/lang/lisp.js"],"names":["module","exports","lisp","displayName","aliases","Prism","simple_form","name","RegExp","primitive","pattern","symbol","marker","par","endpar","space","language","heading","alias","comment","string","greedy","inside","argument","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","rest","varform","forms","arglist","keys","util","clone","sublist","languages","elisp","emacs"],"mappings":"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","file":"x","sourcesContent":["'use strict'\n\nmodule.exports = lisp\nlisp.displayName = 'lisp'\nlisp.aliases = []\nfunction lisp(Prism) {\n  ;(function(Prism) {\n    // Functions to construct regular expressions\n    // simple form\n    // e.g. (interactive ... or (interactive)\n    function simple_form(name) {\n      return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])')\n    } // booleans and numbers\n    function primitive(pattern) {\n      return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])')\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n    var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+' // symbol starting with & used in function arguments\n    var marker = '&' + symbol // Open parenthesis for look-behind\n    var par = '(\\\\()'\n    var endpar = '(?=\\\\))' // End the pattern with look-ahead space\n    var space = '(?=\\\\s)'\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [\n        {\n          pattern: RegExp(\n            par +\n              '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' +\n              space\n          ),\n          lookbehind: true\n        },\n        {\n          pattern: RegExp(\n            par +\n              '(?:for|do|collect|return|finally|append|concat|in|by)' +\n              space\n          ),\n          lookbehind: true\n        }\n      ],\n      declare: {\n        pattern: simple_form('declare'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form('interactive'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive('(?:t|nil)'),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(\n          par +\n            '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' +\n            symbol +\n            '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'\n        ),\n        lookbehind: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n        lookbehind: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [\n        // open paren, brackets, and close paren\n        /(['`,]?\\(|[)\\[\\]])/, // cons\n        {\n          pattern: /(\\s)\\.(?=\\s)/,\n          lookbehind: true\n        }\n      ]\n    }\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      rest: {\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        varform: {\n          pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n          lookbehind: true,\n          inside: {\n            string: language.string,\n            boolean: language.boolean,\n            number: language.number,\n            symbol: language.symbol,\n            punctuation: /[()]/\n          }\n        }\n      }\n    }\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*'\n    var arglist = {\n      pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    }\n    language['lambda'].inside.arguments = arglist\n    language['defun'].inside.arguments = Prism.util.clone(arglist)\n    language['defun'].inside.arguments.inside.sublist = arglist\n    Prism.languages.lisp = language\n    Prism.languages.elisp = language\n    Prism.languages.emacs = language\n    Prism.languages['emacs-lisp'] = language\n  })(Prism)\n}\n"]}}