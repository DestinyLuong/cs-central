{"code":"(this[\"webpackJsonpcs-central\"]=this[\"webpackJsonpcs-central\"]||[]).push([[109],{589:function(e,n,t){\"use strict\";function i(e){!function(e){e.languages.puppet={heredoc:[{pattern:/(@\\(\"([^\"\\r\\n\\/):]+)\"(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,lookbehind:!0,alias:\"string\",inside:{punctuation:/(?=\\S).*\\S(?= *$)/}},{pattern:/(@\\(([^\"\\r\\n\\/):]+)(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,lookbehind:!0,greedy:!0,alias:\"string\",inside:{punctuation:/(?=\\S).*\\S(?= *$)/}},{pattern:/@\\(\"?(?:[^\"\\r\\n\\/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,alias:\"string\",inside:{punctuation:{pattern:/(\\().+?(?=\\))/,lookbehind:!0}}}],\"multiline-comment\":{pattern:/(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,lookbehind:!0,greedy:!0,alias:\"comment\"},regex:{pattern:/((?:\\bnode\\s+|[~=\\(\\[\\{,]\\s*|[=+]>\\s*|^\\s*))\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/(?:[imx]+\\b|\\B)/,lookbehind:!0,greedy:!0,inside:{\"extended-regex\":{pattern:/^\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/[im]*x[im]*$/,inside:{comment:/#.*/}}}},comment:{pattern:/(^|[^\\\\])#.*/,lookbehind:!0,greedy:!0},string:{pattern:/([\"'])(?:\\$\\{(?:[^'\"}]|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}|(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,greedy:!0,inside:{\"double-quoted\":{pattern:/^\"[\\s\\S]*\"$/,inside:{}}}},variable:{pattern:/\\$(?:::)?\\w+(?:::\\w+)*/,inside:{punctuation:/::/}},\"attr-name\":/(?:\\w+|\\*)(?=\\s*=>)/,function:[{pattern:/(\\.)(?!\\d)\\w+/,lookbehind:!0},/\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/],number:/\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,boolean:/\\b(?:true|false)\\b/,keyword:/\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,datatype:{pattern:/\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,alias:\"symbol\"},operator:/=[=~>]?|![=~]?|<(?:<\\|?|[=~|-])?|>[>=]?|->?|~>|\\|>?>?|[*\\/%+?]|\\b(?:and|in|or)\\b/,punctuation:/[\\[\\]{}().,;]|:+/};var n=[{pattern:/(^|[^\\\\])\\$\\{(?:[^'\"{}]|\\{[^}]*\\}|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}/,lookbehind:!0,inside:{\"short-variable\":{pattern:/(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,lookbehind:!0,alias:\"variable\",inside:{punctuation:/::/}},delimiter:{pattern:/^\\$/,alias:\"variable\"},rest:e.languages.puppet}},{pattern:/(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,lookbehind:!0,alias:\"variable\",inside:{punctuation:/::/}}];e.languages.puppet.heredoc[0].inside.interpolation=n,e.languages.puppet.string.inside[\"double-quoted\"].inside.interpolation=n}(e)}e.exports=i,i.displayName=\"puppet\",i.aliases=[]}}]);","name":"static/js/react-syntax-highlighter_languages_refractor_puppet.8e0b4851.chunk.js","map":{"version":3,"sources":["static/js/react-syntax-highlighter_languages_refractor_puppet.8e0b4851.chunk.js"],"names":["this","push","589","module","exports","__webpack_require__","puppet","Prism","languages","heredoc","pattern","lookbehind","alias","inside","punctuation","greedy","multiline-comment","regex","extended-regex","comment","string","double-quoted","variable","attr-name","function","number","boolean","keyword","datatype","operator","interpolation","short-variable","delimiter","rest","displayName","aliases"],"mappings":"CAACA,KAAK,0BAA4BA,KAAK,2BAA6B,IAAIC,KAAK,CAAC,CAAC,KAAK,CAE9EC,IACA,SAAUC,EAAQC,EAASC,GAEjC,aAOA,SAASC,EAAOC,IAGd,SAAWA,GACTA,EAAMC,UAAUF,OAAS,CACvBG,QAAS,CACT,CACEC,QAAS,uGACTC,YAAY,EACZC,MAAO,SACPC,OAAQ,CAENC,YAAa,sBAIjB,CACEJ,QAAS,qGACTC,YAAY,EACZI,QAAQ,EACRH,MAAO,SACPC,OAAQ,CAENC,YAAa,sBAGjB,CACEJ,QAAS,8CACTE,MAAO,SACPC,OAAQ,CACNC,YAAa,CACXJ,QAAS,gBACTC,YAAY,MAIlBK,oBAAqB,CACnBN,QAAS,4BACTC,YAAY,EACZI,QAAQ,EACRH,MAAO,WAETK,MAAO,CAELP,QAAS,uFACTC,YAAY,EACZI,QAAQ,EACRF,OAAQ,CAENK,iBAAkB,CAChBR,QAAS,yCACTG,OAAQ,CACNM,QAAS,UAKjBA,QAAS,CACPT,QAAS,eACTC,YAAY,EACZI,QAAQ,GAEVK,OAAQ,CAENV,QAAS,wFACTK,QAAQ,EACRF,OAAQ,CACNQ,gBAAiB,CACfX,QAAS,cACTG,OAAQ,MAKdS,SAAU,CACRZ,QAAS,yBACTG,OAAQ,CACNC,YAAa,OAGjBS,YAAa,sBACbC,SAAU,CAAC,CACTd,QAAS,gBACTC,YAAY,GACX,oGACHc,OAAQ,+CACRC,QAAS,qBAETC,QAAS,6IACTC,SAAU,CACRlB,QAAS,gNACTE,MAAO,UAETiB,SAAU,mFACVf,YAAa,oBAEf,IAAIgB,EAAgB,CAAC,CAEnBpB,QAAS,0EACTC,YAAY,EACZE,OAAQ,CACNkB,iBAAkB,CAEhBrB,QAAS,uCACTC,YAAY,EACZC,MAAO,WACPC,OAAQ,CACNC,YAAa,OAGjBkB,UAAW,CACTtB,QAAS,MACTE,MAAO,YAETqB,KAAM1B,EAAMC,UAAUF,SAEvB,CACDI,QAAS,kCACTC,YAAY,EACZC,MAAO,WACPC,OAAQ,CACNC,YAAa,QAGjBP,EAAMC,UAAUF,OAAgB,QAAE,GAAGO,OAAOiB,cAAgBA,EAC5DvB,EAAMC,UAAUF,OAAe,OAAEO,OAAO,iBAAiBA,OAAOiB,cAAgBA,EA1HlF,CA2HGvB,GAlILJ,EAAOC,QAAUE,EACjBA,EAAO4B,YAAc,SACrB5B,EAAO6B,QAAU"},"input":"(this[\"webpackJsonpcs-central\"] = this[\"webpackJsonpcs-central\"] || []).push([[109],{\n\n/***/ 589:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = puppet;\npuppet.displayName = 'puppet';\npuppet.aliases = [];\n\nfunction puppet(Prism) {\n  ;\n\n  (function (Prism) {\n    Prism.languages.puppet = {\n      heredoc: [// Matches the content of a quoted heredoc string (subject to interpolation)\n      {\n        pattern: /(@\\(\"([^\"\\r\\n\\/):]+)\"(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,\n        lookbehind: true,\n        alias: 'string',\n        inside: {\n          // Matches the end tag\n          punctuation: /(?=\\S).*\\S(?= *$)/ // See interpolation below\n\n        }\n      }, // Matches the content of an unquoted heredoc string (no interpolation)\n      {\n        pattern: /(@\\(([^\"\\r\\n\\/):]+)(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,\n        lookbehind: true,\n        greedy: true,\n        alias: 'string',\n        inside: {\n          // Matches the end tag\n          punctuation: /(?=\\S).*\\S(?= *$)/\n        }\n      }, // Matches the start tag of heredoc strings\n      {\n        pattern: /@\\(\"?(?:[^\"\\r\\n\\/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,\n        alias: 'string',\n        inside: {\n          punctuation: {\n            pattern: /(\\().+?(?=\\))/,\n            lookbehind: true\n          }\n        }\n      }],\n      'multiline-comment': {\n        pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n        lookbehind: true,\n        greedy: true,\n        alias: 'comment'\n      },\n      regex: {\n        // Must be prefixed with the keyword \"node\" or a non-word char\n        pattern: /((?:\\bnode\\s+|[~=\\(\\[\\{,]\\s*|[=+]>\\s*|^\\s*))\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/(?:[imx]+\\b|\\B)/,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          // Extended regexes must have the x flag. They can contain single-line comments.\n          'extended-regex': {\n            pattern: /^\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/[im]*x[im]*$/,\n            inside: {\n              comment: /#.*/\n            }\n          }\n        }\n      },\n      comment: {\n        pattern: /(^|[^\\\\])#.*/,\n        lookbehind: true,\n        greedy: true\n      },\n      string: {\n        // Allow for one nested level of double quotes inside interpolation\n        pattern: /([\"'])(?:\\$\\{(?:[^'\"}]|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}|(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,\n        greedy: true,\n        inside: {\n          'double-quoted': {\n            pattern: /^\"[\\s\\S]*\"$/,\n            inside: {// See interpolation below\n            }\n          }\n        }\n      },\n      variable: {\n        pattern: /\\$(?:::)?\\w+(?:::\\w+)*/,\n        inside: {\n          punctuation: /::/\n        }\n      },\n      'attr-name': /(?:\\w+|\\*)(?=\\s*=>)/,\n      function: [{\n        pattern: /(\\.)(?!\\d)\\w+/,\n        lookbehind: true\n      }, /\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/],\n      number: /\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,\n      boolean: /\\b(?:true|false)\\b/,\n      // Includes words reserved for future use\n      keyword: /\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,\n      datatype: {\n        pattern: /\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,\n        alias: 'symbol'\n      },\n      operator: /=[=~>]?|![=~]?|<(?:<\\|?|[=~|-])?|>[>=]?|->?|~>|\\|>?>?|[*\\/%+?]|\\b(?:and|in|or)\\b/,\n      punctuation: /[\\[\\]{}().,;]|:+/\n    };\n    var interpolation = [{\n      // Allow for one nested level of braces inside interpolation\n      pattern: /(^|[^\\\\])\\$\\{(?:[^'\"{}]|\\{[^}]*\\}|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}/,\n      lookbehind: true,\n      inside: {\n        'short-variable': {\n          // Negative look-ahead prevent wrong highlighting of functions\n          pattern: /(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,\n          lookbehind: true,\n          alias: 'variable',\n          inside: {\n            punctuation: /::/\n          }\n        },\n        delimiter: {\n          pattern: /^\\$/,\n          alias: 'variable'\n        },\n        rest: Prism.languages.puppet\n      }\n    }, {\n      pattern: /(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,\n      lookbehind: true,\n      alias: 'variable',\n      inside: {\n        punctuation: /::/\n      }\n    }];\n    Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation;\n    Prism.languages.puppet['string'].inside['double-quoted'].inside.interpolation = interpolation;\n  })(Prism);\n}\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/Users/destul/Desktop/cs-central/node_modules/refractor/lang/puppet.js"],"names":["module","exports","puppet","displayName","aliases","Prism","languages","heredoc","pattern","lookbehind","alias","inside","punctuation","greedy","regex","comment","string","variable","function","number","boolean","keyword","datatype","operator","interpolation","delimiter","rest"],"mappings":"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","file":"x","sourcesContent":["'use strict'\n\nmodule.exports = puppet\npuppet.displayName = 'puppet'\npuppet.aliases = []\nfunction puppet(Prism) {\n  ;(function(Prism) {\n    Prism.languages.puppet = {\n      heredoc: [\n        // Matches the content of a quoted heredoc string (subject to interpolation)\n        {\n          pattern: /(@\\(\"([^\"\\r\\n\\/):]+)\"(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,\n          lookbehind: true,\n          alias: 'string',\n          inside: {\n            // Matches the end tag\n            punctuation: /(?=\\S).*\\S(?= *$)/ // See interpolation below\n          }\n        }, // Matches the content of an unquoted heredoc string (no interpolation)\n        {\n          pattern: /(@\\(([^\"\\r\\n\\/):]+)(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,\n          lookbehind: true,\n          greedy: true,\n          alias: 'string',\n          inside: {\n            // Matches the end tag\n            punctuation: /(?=\\S).*\\S(?= *$)/\n          }\n        }, // Matches the start tag of heredoc strings\n        {\n          pattern: /@\\(\"?(?:[^\"\\r\\n\\/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,\n          alias: 'string',\n          inside: {\n            punctuation: {\n              pattern: /(\\().+?(?=\\))/,\n              lookbehind: true\n            }\n          }\n        }\n      ],\n      'multiline-comment': {\n        pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n        lookbehind: true,\n        greedy: true,\n        alias: 'comment'\n      },\n      regex: {\n        // Must be prefixed with the keyword \"node\" or a non-word char\n        pattern: /((?:\\bnode\\s+|[~=\\(\\[\\{,]\\s*|[=+]>\\s*|^\\s*))\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/(?:[imx]+\\b|\\B)/,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          // Extended regexes must have the x flag. They can contain single-line comments.\n          'extended-regex': {\n            pattern: /^\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/[im]*x[im]*$/,\n            inside: {\n              comment: /#.*/\n            }\n          }\n        }\n      },\n      comment: {\n        pattern: /(^|[^\\\\])#.*/,\n        lookbehind: true,\n        greedy: true\n      },\n      string: {\n        // Allow for one nested level of double quotes inside interpolation\n        pattern: /([\"'])(?:\\$\\{(?:[^'\"}]|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}|(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,\n        greedy: true,\n        inside: {\n          'double-quoted': {\n            pattern: /^\"[\\s\\S]*\"$/,\n            inside: {\n              // See interpolation below\n            }\n          }\n        }\n      },\n      variable: {\n        pattern: /\\$(?:::)?\\w+(?:::\\w+)*/,\n        inside: {\n          punctuation: /::/\n        }\n      },\n      'attr-name': /(?:\\w+|\\*)(?=\\s*=>)/,\n      function: [\n        {\n          pattern: /(\\.)(?!\\d)\\w+/,\n          lookbehind: true\n        },\n        /\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/\n      ],\n      number: /\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,\n      boolean: /\\b(?:true|false)\\b/,\n      // Includes words reserved for future use\n      keyword: /\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,\n      datatype: {\n        pattern: /\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,\n        alias: 'symbol'\n      },\n      operator: /=[=~>]?|![=~]?|<(?:<\\|?|[=~|-])?|>[>=]?|->?|~>|\\|>?>?|[*\\/%+?]|\\b(?:and|in|or)\\b/,\n      punctuation: /[\\[\\]{}().,;]|:+/\n    }\n    var interpolation = [\n      {\n        // Allow for one nested level of braces inside interpolation\n        pattern: /(^|[^\\\\])\\$\\{(?:[^'\"{}]|\\{[^}]*\\}|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}/,\n        lookbehind: true,\n        inside: {\n          'short-variable': {\n            // Negative look-ahead prevent wrong highlighting of functions\n            pattern: /(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,\n            lookbehind: true,\n            alias: 'variable',\n            inside: {\n              punctuation: /::/\n            }\n          },\n          delimiter: {\n            pattern: /^\\$/,\n            alias: 'variable'\n          },\n          rest: Prism.languages.puppet\n        }\n      },\n      {\n        pattern: /(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,\n        lookbehind: true,\n        alias: 'variable',\n        inside: {\n          punctuation: /::/\n        }\n      }\n    ]\n    Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation\n    Prism.languages.puppet['string'].inside[\n      'double-quoted'\n    ].inside.interpolation = interpolation\n  })(Prism)\n}\n"]}}