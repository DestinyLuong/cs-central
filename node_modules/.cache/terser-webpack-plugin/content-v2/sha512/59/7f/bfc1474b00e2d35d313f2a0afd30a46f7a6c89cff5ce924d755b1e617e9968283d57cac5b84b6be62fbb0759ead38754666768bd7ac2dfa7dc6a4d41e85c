{"code":"(this[\"webpackJsonpcs-central\"]=this[\"webpackJsonpcs-central\"]||[]).push([[96],{577:function(r,e,n){\"use strict\";function o(r){r.languages.parigp={comment:/\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,string:{pattern:/\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,greedy:!0},keyword:function(){var r=[\"breakpoint\",\"break\",\"dbg_down\",\"dbg_err\",\"dbg_up\",\"dbg_x\",\"forcomposite\",\"fordiv\",\"forell\",\"forpart\",\"forprime\",\"forstep\",\"forsubgroup\",\"forvec\",\"for\",\"iferr\",\"if\",\"local\",\"my\",\"next\",\"return\",\"until\",\"while\"];return r=r.map((function(r){return r.split(\"\").join(\" *\")})).join(\"|\"),RegExp(\"\\\\b(?:\"+r+\")\\\\b\")}(),function:/\\w[\\w ]*?(?= *\\()/,number:{pattern:/((?:\\. *\\. *)?)(?:\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *[+-]? *\\d(?: *\\d)*)?/i,lookbehind:!0},operator:/\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?:(?: *<)?(?: *=)?| *>)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,punctuation:/[\\[\\]{}().,:;|]/}}r.exports=o,o.displayName=\"parigp\",o.aliases=[]}}]);","name":"static/js/react-syntax-highlighter_languages_refractor_parigp.5681f2af.chunk.js","map":{"version":3,"sources":["static/js/react-syntax-highlighter_languages_refractor_parigp.5681f2af.chunk.js"],"names":["this","push","577","module","exports","__webpack_require__","parigp","Prism","languages","comment","string","pattern","greedy","keyword","keywords","map","split","join","RegExp","function","number","lookbehind","operator","punctuation","displayName","aliases"],"mappings":"CAACA,KAAK,0BAA4BA,KAAK,2BAA6B,IAAIC,KAAK,CAAC,CAAC,IAAI,CAE7EC,IACA,SAAUC,EAAQC,EAASC,GAEjC,aAOA,SAASC,EAAOC,GACdA,EAAMC,UAAUF,OAAS,CACvBG,QAAS,0BACTC,OAAQ,CACNC,QAAS,wBACTC,QAAQ,GAKVC,QAAS,WACP,IAAIC,EAAW,CAAC,aAAc,QAAS,WAAY,UAAW,SAAU,QAAS,eAAgB,SAAU,SAAU,UAAW,WAAY,UAAW,cAAe,SAAU,MAAO,QAAS,KAAM,QAAS,KAAM,OAAQ,SAAU,QAAS,SAIhP,OAHAA,EAAWA,EAASC,KAAI,SAAUF,GAChC,OAAOA,EAAQG,MAAM,IAAIC,KAAK,SAC7BA,KAAK,KACDC,OAAO,SAAWJ,EAAW,QAL7B,GAOTK,SAAU,oBACVC,OAAQ,CAENT,QAAS,0GACTU,YAAY,GAEdC,SAAU,sLACVC,YAAa,mBA5BjBpB,EAAOC,QAAUE,EACjBA,EAAOkB,YAAc,SACrBlB,EAAOmB,QAAU"},"input":"(this[\"webpackJsonpcs-central\"] = this[\"webpackJsonpcs-central\"] || []).push([[96],{\n\n/***/ 577:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = parigp;\nparigp.displayName = 'parigp';\nparigp.aliases = [];\n\nfunction parigp(Prism) {\n  Prism.languages.parigp = {\n    comment: /\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,\n    string: {\n      pattern: /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n      greedy: true\n    },\n    // PARI/GP does not care about white spaces at all\n    // so let's process the keywords to build an appropriate regexp\n    // (e.g. \"b *r *e *a *k\", etc.)\n    keyword: function () {\n      var keywords = ['breakpoint', 'break', 'dbg_down', 'dbg_err', 'dbg_up', 'dbg_x', 'forcomposite', 'fordiv', 'forell', 'forpart', 'forprime', 'forstep', 'forsubgroup', 'forvec', 'for', 'iferr', 'if', 'local', 'my', 'next', 'return', 'until', 'while'];\n      keywords = keywords.map(function (keyword) {\n        return keyword.split('').join(' *');\n      }).join('|');\n      return RegExp('\\\\b(?:' + keywords + ')\\\\b');\n    }(),\n    function: /\\w[\\w ]*?(?= *\\()/,\n    number: {\n      // The lookbehind and the negative lookahead prevent from breaking the .. operator\n      pattern: /((?:\\. *\\. *)?)(?:\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *[+-]? *\\d(?: *\\d)*)?/i,\n      lookbehind: true\n    },\n    operator: /\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?:(?: *<)?(?: *=)?| *>)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,\n    punctuation: /[\\[\\]{}().,:;|]/\n  };\n}\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/Users/destul/Desktop/cs-central/node_modules/refractor/lang/parigp.js"],"names":["module","exports","parigp","displayName","aliases","Prism","languages","comment","string","pattern","greedy","keyword","keywords","map","split","join","RegExp","function","number","lookbehind","operator","punctuation"],"mappings":";;;;;;AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,MAAjB;AACAA,MAAM,CAACC,WAAP,GAAqB,QAArB;AACAD,MAAM,CAACE,OAAP,GAAiB,EAAjB;;AACA,SAASF,MAAT,CAAgBG,KAAhB,EAAuB;AACrBA,OAAK,CAACC,SAAN,CAAgBJ,MAAhB,GAAyB;AACvBK,WAAO,EAAE,yBADc;AAEvBC,UAAM,EAAE;AACNC,aAAO,EAAE,uBADH;AAENC,YAAM,EAAE;AAFF,KAFe;AAMvB;AACA;AACA;AACAC,WAAO,EAAG,YAAW;AACnB,UAAIC,QAAQ,GAAG,CACb,YADa,EAEb,OAFa,EAGb,UAHa,EAIb,SAJa,EAKb,QALa,EAMb,OANa,EAOb,cAPa,EAQb,QARa,EASb,QATa,EAUb,SAVa,EAWb,UAXa,EAYb,SAZa,EAab,aAba,EAcb,QAda,EAeb,KAfa,EAgBb,OAhBa,EAiBb,IAjBa,EAkBb,OAlBa,EAmBb,IAnBa,EAoBb,MApBa,EAqBb,QArBa,EAsBb,OAtBa,EAuBb,OAvBa,CAAf;AAyBAA,cAAQ,GAAGA,QAAQ,CAChBC,GADQ,CACJ,UAASF,OAAT,EAAkB;AACrB,eAAOA,OAAO,CAACG,KAAR,CAAc,EAAd,EAAkBC,IAAlB,CAAuB,IAAvB,CAAP;AACD,OAHQ,EAIRA,IAJQ,CAIH,GAJG,CAAX;AAKA,aAAOC,MAAM,CAAC,WAAWJ,QAAX,GAAsB,MAAvB,CAAb;AACD,KAhCQ,EATc;AA0CvBK,YAAQ,EAAE,mBA1Ca;AA2CvBC,UAAM,EAAE;AACN;AACAT,aAAO,EAAE,yGAFH;AAGNU,gBAAU,EAAE;AAHN,KA3Ce;AAgDvBC,YAAQ,EAAE,qLAhDa;AAiDvBC,eAAW,EAAE;AAjDU,GAAzB;AAmDD,C","file":"x","sourcesContent":["'use strict'\n\nmodule.exports = parigp\nparigp.displayName = 'parigp'\nparigp.aliases = []\nfunction parigp(Prism) {\n  Prism.languages.parigp = {\n    comment: /\\/\\*[\\s\\S]*?\\*\\/|\\\\\\\\.*/,\n    string: {\n      pattern: /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"/,\n      greedy: true\n    },\n    // PARI/GP does not care about white spaces at all\n    // so let's process the keywords to build an appropriate regexp\n    // (e.g. \"b *r *e *a *k\", etc.)\n    keyword: (function() {\n      var keywords = [\n        'breakpoint',\n        'break',\n        'dbg_down',\n        'dbg_err',\n        'dbg_up',\n        'dbg_x',\n        'forcomposite',\n        'fordiv',\n        'forell',\n        'forpart',\n        'forprime',\n        'forstep',\n        'forsubgroup',\n        'forvec',\n        'for',\n        'iferr',\n        'if',\n        'local',\n        'my',\n        'next',\n        'return',\n        'until',\n        'while'\n      ]\n      keywords = keywords\n        .map(function(keyword) {\n          return keyword.split('').join(' *')\n        })\n        .join('|')\n      return RegExp('\\\\b(?:' + keywords + ')\\\\b')\n    })(),\n    function: /\\w[\\w ]*?(?= *\\()/,\n    number: {\n      // The lookbehind and the negative lookahead prevent from breaking the .. operator\n      pattern: /((?:\\. *\\. *)?)(?:\\d(?: *\\d)*(?: *(?!\\. *\\.)\\.(?: *\\d)*)?|\\. *\\d(?: *\\d)*)(?: *e *[+-]? *\\d(?: *\\d)*)?/i,\n      lookbehind: true\n    },\n    operator: /\\. *\\.|[*\\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\\+(?: *[+=])?|-(?: *[-=>])?|<(?:(?: *<)?(?: *=)?| *>)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\\\(?: *\\/)?(?: *=)?|&(?: *&)?|\\| *\\||['#~^]/,\n    punctuation: /[\\[\\]{}().,:;|]/\n  }\n}\n"]}}